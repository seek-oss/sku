import { parse } from '@babel/parser';
import _traverse from '@babel/traverse';
import _generate from '@babel/generator';
import * as t from '@babel/types';
import type { Plugin } from 'vite';
import {
  VITE_LOADABLE_IMPORT,
  WEBPACK_LOADABLE_IMPORT,
} from './helpers/constants.js';
import { getViteLoadableSpecifierName } from './helpers/getViteLoadableSpecifierName.js';
import { getWebpackLoadableSpecifierName } from './helpers/getWebpackLoadableSpecifierName.js';
import { convertWebpackToViteImport } from './helpers/convertWebpackToViteImport.js';
import { injectModuleID } from './helpers/injectModuleID.js';

/* NOTE: This implementation can probably be improved and simplified.
 * My primary goal was to get it working and replacing but my limited experience with AST parsing is likely showing.
 * Any improvements here are encouraged and more than welcome.
 */

const traverse = _traverse.default;
const generate = _generate.default;

interface PluginOptions {
  /**
   * Enables extensive build logs
   */
  debug?: boolean;
  /**
   * Convert loadable import from webpack to vite
   */
  convertFromWebpack?: boolean;
}

// Modules to scan for dynamic imports
const include = /\.(jsx?|tsx?)$/;

// Find all JSX files that have the `loadable` import.
// Find the `loadable` import and inject the moduleId into the third argument.
// ModuleId should be the path of the file relative to the project root.
// This corresponds with the manifest.json that is generated by Vite.
export default function skuVitePreloadPlugin({
  debug,
  convertFromWebpack,
}: PluginOptions = {}): Plugin {
  const lazyImportedModules = new Set();
  const injectedModules = new Set();
  let count = 0;
  let isSsr = false;

  return {
    name: 'vite-plugin-sku-vite-preload',

    apply(config) {
      // Enable on SSR builds (--ssr)
      isSsr = Boolean(config.build?.ssr);
      return true;
    },

    async transform(code, id) {
      if (!include.test(id)) {
        return null;
      }

      if (
        code.includes(WEBPACK_LOADABLE_IMPORT) &&
        code.includes(VITE_LOADABLE_IMPORT)
      ) {
        throw new Error(
          `Both ${WEBPACK_LOADABLE_IMPORT} and ${VITE_LOADABLE_IMPORT} imports found in ${id}. Please remove one of them.`,
        );
      }

      let ast;
      // Find dynamic imports
      if (
        code.includes(WEBPACK_LOADABLE_IMPORT) ||
        code.includes(VITE_LOADABLE_IMPORT)
      ) {
        ast = parse(code, {
          sourceType: 'module',
          plugins: ['jsx', 'typescript'],
        });

        let injected = false;

        let loadableFunctionIdentifier = 'loadable';

        traverse(ast, {
          ImportDeclaration(importPath) {
            if (
              !convertFromWebpack &&
              code.includes(WEBPACK_LOADABLE_IMPORT) &&
              !code.includes(VITE_LOADABLE_IMPORT)
            ) {
              console.log(
                `Webpack loadable import found but no vite loadable import for file ${id}. This can have unintended side effects and the files may not load propperly.`,
              );
              return;
            }

            // Find the loadable import name and see if it has been aliased.
            if (
              t.isLiteral(importPath.node.source, {
                value: VITE_LOADABLE_IMPORT,
              })
            ) {
              loadableFunctionIdentifier =
                getViteLoadableSpecifierName(importPath);
              return;
            }

            if (
              t.isLiteral(importPath.node.source, {
                value: WEBPACK_LOADABLE_IMPORT,
              })
            ) {
              loadableFunctionIdentifier =
                getWebpackLoadableSpecifierName(importPath);
              convertWebpackToViteImport(importPath);
              // Handle imports of loadableReady imports here too.
            }
          },
          CallExpression(callPath) {
            // only inject the module ID for ssr builds.
            if (
              callPath
                .get('callee')
                .isIdentifier({ name: loadableFunctionIdentifier }) &&
              isSsr
            ) {
              injected = injectModuleID({
                callPath,
                id,
              });
            }
          },
        });

        if (injected) {
          if (debug) {
            this.info('Injected moduleId in React component');
          }
          count++;
          injectedModules.add(id);
        }
        const output = generate(ast, {}, code);
        return {
          code: output.code,
          map: output.map,
        };
      }

      return null;
    },

    buildEnd() {
      if (debug) {
        for (const lazyModule of lazyImportedModules) {
          if (!injectedModules.has(lazyModule)) {
            this.warn(`${lazyModule} was not injected FOR`);
          }
        }
      }
      this.info(`${count} hook calls injected`);
    },
  };
}
