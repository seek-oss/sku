import { parse } from '@babel/parser';
import _traverse from '@babel/traverse';
import _generate from '@babel/generator';
import * as t from '@babel/types';
import {
  resolve,
  dirname,
  relative,
  parse as pathParse,
  extname,
} from 'node:path';
import type { Plugin } from 'vite';
import { readdirSync } from 'node:fs';

/* NOTE: This implementation can probably be improved and simplified.
 * My primary goal was to get it working and replacing but my limited experience with AST parsing is likely showing.
 * Any improvements here are encouraged and more than welcome.
 */

const traverse = _traverse.default;
const generate = _generate.default;

const getRelativePath = (filePath: string) =>
  relative(process.cwd(), filePath).replace(/\\/g, '/');

interface PluginOptions {
  /**
   * Enables extensive build logs
   */
  debug?: boolean;
}

const loadablefunctionName = 'loadable';

// Modules to scan for dynamic imports
const include = /\.(jsx?|tsx?)$/;

// Find all JSX files that have the `loadable` import.
// Find the `loadable` import and inject the moduleId into the second argument.
// ModuleId should be the path of the file relative to the project root.
// This corresponds with the manifest.json that is generated by Vite.
export default function skuVitePreloadPlugin({
  debug,
}: PluginOptions = {}): Plugin {
  const lazyImportedModules = new Set();
  const injectedModules = new Set();
  let count = 0;

  return {
    name: 'vite-plugin-sku-vite-preload',

    apply(config) {
      // Enable on SSR builds (--ssr)
      return Boolean(config.build?.ssr);
    },

    async transform(code, id) {
      if (!include.test(id)) {
        return null;
      }
      let ast: ReturnType<typeof parse>;

      // TODO: Do some better checking. Not every function thats called `loadable` is the correct one.
      // TODO: Make sure that the import is correct as well to failsafe.
      // Find dynamic imports
      if (code.includes(' import(')) {
        ast = parse(code, {
          sourceType: 'module',
          plugins: ['jsx', 'typescript'],
        });

        let injected = false;

        traverse(ast, {
          CallExpression(callPath) {
            if (
              callPath
                .get('callee')
                .isIdentifier({ name: loadablefunctionName })
            ) {
              // TODO: This can be cleaned up. perhaps not doing filesystem reads to get the file ext.
              const importArg = callPath.get('arguments')[0];
              importArg.traverse({
                Import(importPath) {
                  // @ts-expect-error
                  if (!importPath.parent.arguments) {
                    return;
                  }
                  // @ts-expect-error
                  const importArgument = importPath.parent.arguments[0];

                  if (importArgument) {
                    // Dynamic import of a dynamic module is not supported
                    if (importArgument.type === 'StringLiteral') {
                      const absolutePath = resolve(
                        dirname(id),
                        importArgument.value,
                      );
                      const files = readdirSync(dirname(absolutePath));
                      const name = pathParse(absolutePath).base;

                      const found = files.find(
                        (x) =>
                          x.replace(extname(x), '') ===
                          name.replace(extname(name), ''),
                      );
                      const relativePath = getRelativePath(
                        `${dirname(absolutePath)}/${found}`,
                      );

                      callPath.node.arguments.push(
                        t.stringLiteral(relativePath),
                      );
                      injected = true;
                    }
                  }
                },
              });
            }
          },
        });

        if (injected) {
          if (debug) {
            this.info('Injected moduleId in React component');
          }
          count++;
          const output = generate(ast, {}, code);
          injectedModules.add(id);
          return {
            code: output.code,
            map: output.map,
          };
        }
      }

      return null;
    },

    buildEnd() {
      if (debug) {
        const s = lazyImportedModules.difference(injectedModules);
        for (const z of s) {
          this.warn(`${z} was not injected`);
        }
      }
      this.info(`${count} hook calls injected`);
    },
  };
}
