import { describe, beforeAll, afterAll, it, expect } from 'vitest';
import { readFile, copyFile, mkdir as makeDir, rm } from 'node:fs/promises';
import path from 'node:path';
import * as jsonc from 'jsonc-parser';

import prettierConfig from '../packages/sku/dist/services/prettier/config/prettierConfig.js';

import { scopeToFixture, waitFor } from '@sku-private/testing-library';

const sanitizeEslintConfig = (eslintConfig: string) =>
  eslintConfig.replaceAll(process.cwd(), '{cwd}');

const readFileContents = async (appDir: string, fileName: string) => {
  const contents = await readFile(path.join(appDir, fileName), 'utf-8');
  return contents;
};

const readJsonC = async (appDir: string, fileName: string) => {
  const contents = await readFileContents(appDir, fileName);
  return jsonc.parse(contents);
};

const readIgnore = async (appDir: string, fileName: string) => {
  const contents = await readFileContents(appDir, fileName);
  return contents
    .split('\n')
    .filter((ignore) => ignore && !ignore.startsWith('#')); // remove blanks and comments
};

const copyToApp = async (filename: string, folder: string) =>
  copyFile(joinPath(filename), path.join(folder, filename));

const removeAppDir = async (folder: string) =>
  rm(folder, {
    recursive: true,
    force: true,
  });

const { render, joinPath } = scopeToFixture('configure');

describe('configure', () => {
  describe('javascript app', () => {
    const appFolder = joinPath('App');

    beforeAll(async () => {
      await makeDir(appFolder);
      await makeDir(path.join(appFolder, './src'));
      await copyToApp('src/App.tsx', appFolder);
      await copyToApp('package.json', appFolder);

      const configure = await render('configure', [], {
        cwd: './App',
      });

      await waitFor(() => {
        expect(configure.hasExit()).toMatchObject({ exitCode: 0 });
      });
    });

    afterAll(async () => {
      await removeAppDir(appFolder);
    });

    it('should generate a prettier config', async () => {
      const prettierRc = await readJsonC(appFolder, '.prettierrc');
      expect(prettierRc).toEqual(prettierConfig);
    });

    it('should generate a eslint config', async () => {
      const eslintConfig = await readFileContents(
        appFolder,
        'eslint.config.mjs',
      );

      expect(sanitizeEslintConfig(eslintConfig)).toMatchInlineSnapshot(`
        "/** THIS FILE IS GENERATED BY SKU, MANUAL CHANGES WILL BE DISCARDED **/
        import { createEslintConfig } from 'sku/config/eslint';

        export default createEslintConfig();"
      `);
    });

    it.for(['.prettierignore', '.gitignore'])(
      'should generate %s',
      async (ignore) => {
        const ignoreContents = await readIgnore(appFolder, ignore);

        expect(ignoreContents).toMatchSnapshot();
      },
    );
  });

  describe('typescript app', () => {
    const appFolderTS = joinPath('TSApp');

    beforeAll(async () => {
      await makeDir(appFolderTS);
      await makeDir(path.join(appFolderTS, './src'));
      await copyToApp('src/App.tsx', appFolderTS);
      await copyToApp('package.json', appFolderTS);
      await copyToApp('sku.config.ts', appFolderTS);

      const configure = await render('configure', [], {
        cwd: './TSApp',
      });

      await waitFor(() => {
        expect(configure.hasExit()).toMatchObject({ exitCode: 0 });
      });
    });

    afterAll(async () => {
      await removeAppDir(appFolderTS);
    });

    it('should generate a prettier config', async () => {
      const prettierRc = await readJsonC(appFolderTS, '.prettierrc');

      expect(prettierRc).toEqual(prettierConfig);
    });

    it('should generate an eslint config', async () => {
      const eslintConfig = await readFileContents(
        appFolderTS,
        'eslint.config.mjs',
      );

      expect(sanitizeEslintConfig(eslintConfig)).toMatchInlineSnapshot(`
        "/** THIS FILE IS GENERATED BY SKU, MANUAL CHANGES WILL BE DISCARDED **/
        import { createEslintConfig } from 'sku/config/eslint';

        export default createEslintConfig('{cwd}/fixtures/configure/TSApp/sku.config.ts');"
      `);
    });

    it('should generate tsconfig config', async () => {
      const tsconfigContents = await readJsonC(appFolderTS, 'tsconfig.json');

      expect(Object.keys(tsconfigContents).sort()).toEqual(['compilerOptions']);
    });

    it.for(['.prettierignore', '.gitignore'])(
      'should generate %s',
      async (ignore) => {
        const ignoreContents = await readIgnore(appFolderTS, ignore);

        expect(ignoreContents).toMatchSnapshot();
      },
    );
  });
});
